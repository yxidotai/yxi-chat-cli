"""Generate Playwright test scripts from Excel test cases and optionally run them."""
from __future__ import annotations

import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

import pandas as pd
from playwright.sync_api import expect, sync_playwright


@dataclass
class PlaywrightOptions:
    headless: bool = True
    slow_mo: int = 0
    timeout_ms: int = 10000
    base_url: Optional[str] = None
    output_dir: Optional[str] = None
    browser: str = "chromium"


def _normalize_columns(cols: Iterable[Any]) -> List[str]:
    return [str(c).strip().lower() for c in cols]


def _pick_value(row: Dict[str, Any], keys: Iterable[str]) -> Optional[Any]:
    for key in keys:
        if key in row and row[key] not in (None, "", "nan", "NaN"):
            return row[key]
    return None


def _to_int(value: Any) -> Optional[int]:
    if value in (None, "", "nan", "NaN"):
        return None
    try:
        return int(float(value))
    except (TypeError, ValueError):
        return None


def load_cases_from_excel(path: str) -> List[Dict[str, Any]]:
    xlsx_path = Path(path).expanduser().resolve()
    if not xlsx_path.exists():
        raise FileNotFoundError(f"Excel file not found: {xlsx_path}")

    sheets = pd.read_excel(xlsx_path, sheet_name=None, engine="openpyxl")
    cases: Dict[str, Dict[str, Any]] = {}
    auto_case_counter = 1

    for sheet_name, df in sheets.items():
        if df is None or df.empty:
            continue
        df = df.copy()
        df.columns = _normalize_columns(df.columns)
        records = df.to_dict(orient="records")

        for idx, raw in enumerate(records, start=1):
            row = {str(k).strip().lower(): v for k, v in raw.items()}

            case_id = _pick_value(row, ["case_id", "case", "test_id", "id", "用例id", "用例", "编号"])
            title = _pick_value(row, ["title", "name", "case_title", "test_name", "用例标题", "标题"])
            case_key = str(case_id or title or f"{sheet_name}-{auto_case_counter}")
            if case_key not in cases:
                cases[case_key] = {
                    "id": case_id or f"case-{auto_case_counter}",
                    "title": title or f"{sheet_name} case {auto_case_counter}",
                    "steps": [],
                }
                auto_case_counter += 1

            action = _pick_value(row, ["action", "step_action", "操作", "动作"]) or ""
            selector = _pick_value(row, ["selector", "target", "css", "xpath", "元素", "定位"])
            value = _pick_value(row, ["value", "text", "input", "输入", "值"])
            url = _pick_value(row, ["url", "link", "链接", "路径"])
            expect_text = _pick_value(row, ["expect", "expected", "assert_text", "断言", "期望"])
            wait_ms = _to_int(_pick_value(row, ["wait_ms", "wait", "delay", "等待"]))
            screenshot = _pick_value(row, ["screenshot", "snapshot", "截图"])

            step: Dict[str, Any] = {
                "action": str(action).strip().lower(),
                "selector": selector,
                "value": value,
                "url": url,
                "expect": expect_text,
                "wait_ms": wait_ms,
                "screenshot": screenshot,
                "sheet": sheet_name,
                "row": idx,
            }

            if not step["action"] and step.get("url"):
                step["action"] = "goto"

            cases[case_key]["steps"].append(step)

    return list(cases.values())


def _resolve_url(url: Optional[str], base_url: Optional[str]) -> Optional[str]:
    if not url:
        return None
    url = str(url).strip()
    if not base_url:
        return url
    if re.match(r"^https?://", url):
        return url
    if url.startswith("/"):
        return base_url.rstrip("/") + url
    return base_url.rstrip("/") + "/" + url


def generate_playwright_script(cases: List[Dict[str, Any]], options: PlaywrightOptions) -> str:
    payload = json.dumps(cases, ensure_ascii=False, indent=2)
    opts = json.dumps(options.__dict__, ensure_ascii=False, indent=2)

    script = """# Generated by yxi-chat-cli Playwright agent
import json
from pathlib import Path
from playwright.sync_api import sync_playwright, expect

CASES = __CASES__
OPTIONS = __OPTIONS__


def _resolve_url(url, base_url):
    if not url:
        return None
    if url.startswith("http://") or url.startswith("https://"):
        return url
    if base_url:
        base = base_url.rstrip("/")
        if url.startswith("/"):
            return base + url
        return base + "/" + url
    return url


def run_cases():
    results = []
    output_dir = OPTIONS.get("output_dir")
    if output_dir:
        Path(output_dir).mkdir(parents=True, exist_ok=True)

    with sync_playwright() as p:
        browser_type = getattr(p, OPTIONS.get("browser", "chromium"), p.chromium)
        browser = browser_type.launch(
            headless=OPTIONS.get("headless", True),
            slow_mo=OPTIONS.get("slow_mo", 0),
        )
        context = browser.new_context()
        page = context.new_page()
        page.set_default_timeout(OPTIONS.get("timeout_ms", 10000))

        for case in CASES:
            case_result = {
                "id": case.get("id"),
                "title": case.get("title"),
                "status": "passed",
                "steps": [],
            }
            for index, step in enumerate(case.get("steps", []), start=1):
                step_result = {"index": index, "status": "passed", "action": step.get("action")}
                try:
                    action = (step.get("action") or "").lower()
                    selector = step.get("selector")
                    value = step.get("value")
                    url = _resolve_url(step.get("url"), OPTIONS.get("base_url"))
                    wait_ms = step.get("wait_ms")

                    if action in ("goto", "visit", "open", "navigate"):
                        page.goto(url)
                    elif action in ("click", "tap"):
                        page.click(selector)
                    elif action in ("fill", "type", "input"):
                        page.fill(selector, "" if value is None else str(value))
                    elif action in ("press", "key"):
                        page.press(selector, "" if value is None else str(value))
                    elif action in ("expect_text", "assert_text", "expect"):
                        if selector:
                            expect(page.locator(selector)).to_have_text(str(value))
                        else:
                            expect(page.locator("body")).to_contain_text(str(value))
                    elif action in ("expect_visible", "assert_visible", "visible"):
                        expect(page.locator(selector)).to_be_visible()
                    elif action in ("wait", "sleep", "delay"):
                        page.wait_for_timeout(int(wait_ms or 0))
                    elif action in ("screenshot", "snap"):
                        name = step.get("screenshot") or f"case_{case.get('id')}_step_{index}.png"
                        path = Path(output_dir or ".") / name
                        page.screenshot(path=str(path), full_page=True)
                    else:
                        raise ValueError(f"Unsupported action: {action}")
                except Exception as exc:
                    step_result["status"] = "failed"
                    step_result["error"] = str(exc)
                    case_result["status"] = "failed"
                case_result["steps"].append(step_result)
            results.append(case_result)

        browser.close()

    return results


if __name__ == "__main__":
    output = run_cases()
    print(json.dumps(output, ensure_ascii=False, indent=2))
"""

    return script.replace("__CASES__", payload).replace("__OPTIONS__", opts)


def run_cases(cases: List[Dict[str, Any]], options: PlaywrightOptions) -> List[Dict[str, Any]]:
    results: List[Dict[str, Any]] = []
    output_dir = options.output_dir
    if output_dir:
        Path(output_dir).mkdir(parents=True, exist_ok=True)

    with sync_playwright() as p:
        browser_type = getattr(p, options.browser, p.chromium)
        browser = browser_type.launch(headless=options.headless, slow_mo=options.slow_mo)
        context = browser.new_context()
        page = context.new_page()
        page.set_default_timeout(options.timeout_ms)

        for case in cases:
            case_result = {
                "id": case.get("id"),
                "title": case.get("title"),
                "status": "passed",
                "steps": [],
            }
            for index, step in enumerate(case.get("steps", []), start=1):
                step_result = {"index": index, "status": "passed", "action": step.get("action")}
                try:
                    action = (step.get("action") or "").lower()
                    selector = step.get("selector")
                    value = step.get("value")
                    url = _resolve_url(step.get("url"), options.base_url)
                    wait_ms = step.get("wait_ms")

                    if action in ("goto", "visit", "open", "navigate"):
                        page.goto(url)
                    elif action in ("click", "tap"):
                        page.click(selector)
                    elif action in ("fill", "type", "input"):
                        page.fill(selector, "" if value is None else str(value))
                    elif action in ("press", "key"):
                        page.press(selector, "" if value is None else str(value))
                    elif action in ("expect_text", "assert_text", "expect"):
                        if selector:
                            expect(page.locator(selector)).to_have_text(str(value))
                        else:
                            expect(page.locator("body")).to_contain_text(str(value))
                    elif action in ("expect_visible", "assert_visible", "visible"):
                        expect(page.locator(selector)).to_be_visible()
                    elif action in ("wait", "sleep", "delay"):
                        page.wait_for_timeout(int(wait_ms or 0))
                    elif action in ("screenshot", "snap"):
                        name = step.get("screenshot") or f"case_{case.get('id')}_step_{index}.png"
                        path = Path(output_dir or ".") / name
                        page.screenshot(path=str(path), full_page=True)
                    else:
                        raise ValueError(f"Unsupported action: {action}")
                except Exception as exc:
                    step_result["status"] = "failed"
                    step_result["error"] = str(exc)
                    case_result["status"] = "failed"
                case_result["steps"].append(step_result)
            results.append(case_result)

        browser.close()

    return results
